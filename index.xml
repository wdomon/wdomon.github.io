<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Admin Brain Dump</title><link>https://adminbraindump.com/</link><description>Recent content on Admin Brain Dump</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 25 Aug 2024 08:15:56 -0700</lastBuildDate><atom:link href="https://adminbraindump.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Restrict Graph API Permissions for Exchange Online or Teams/Sharepoint Online</title><link>https://adminbraindump.com/post/restrict-graph-api/</link><pubDate>Sun, 25 Aug 2024 08:15:56 -0700</pubDate><guid>https://adminbraindump.com/post/restrict-graph-api/</guid><description>&lt;p>Graph API permissions via EntraID app registrations have become even more popular over the last couple of years. While they are definitely an upgrade over old school &amp;ldquo;service accounts,&amp;rdquo; granting an app access to an Exchange Online(EXO) mailbox or a Teams/Sharepoint Online(SPO) site using Graph API permissions can result in far more permissions being granted than are needed (or realized).&lt;/p>
&lt;p>Many 3rd party applications/vendors, and even flows built within your own Power Automate tenant, etc. will request an app registration with a list of Graph API permissions that their app &amp;ldquo;needs.&amp;rdquo; If this app requires the ability to access a single mailbox, for example, they will request &lt;code>Mail.Read&lt;/code> or &lt;code>Mail.ReadWrite&lt;/code> as the application permission they need. However, what some people don&amp;rsquo;t pick up on is that this is actually granting this app permission to access EVERY mailbox in the entire tenant; shared mailboxes, user mailboxes, resource mailboxes, the CEO/CFO&amp;rsquo;s mailbox&amp;hellip; you get the point. Granting &lt;code>Sites.Read.All&lt;/code> or &lt;code>Sites.ReadWrite.All&lt;/code> do the same for every Teams/OneDrive/SPO site as well. Luckily, Microsoft has introduced features in Microsoft Graph that provide more granular control over app access to specific SPO/Teams site collections and Exchange Online mailboxes. This post will walk you through the process of configuring these features to ensure that your applications only have access to the necessary resources.&lt;/p>
&lt;h3 id="scoping-microsoft-graph-permissions-for-exchange-online-mailboxes">Scoping Microsoft Graph Permissions for Exchange Online Mailboxes&lt;/h3>
&lt;p>A significant enhancement is the ability to scope Microsoft Graph permissions to specific Exchange Online mailboxes using the Application Access Policy feature. This is particularly useful in scenarios where an app needs to access only a subset of mailboxes within an organization. This feature is actually just a configuration within EXO using the &lt;a class="link" href="https://www.powershellgallery.com/packages/ExchangeOnlineManagement/3.5.1" target="_blank" rel="noopener"
>ExchangeOnlineManagement&lt;/a> Powershell module and not with MS Graph itself.&lt;/p>
&lt;h4 id="configure-application-access-policy">Configure Application Access Policy&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>Connect to Exchange Online PowerShell: First, connect to Exchange Online PowerShell. You can use the Azure Cloud Shell or any other preferred method to do this.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Identify the App and Security Group: Identify your app’s clientID and either create a new mail-enabled security group or use an existing one; identify the email address of this group. This group will be used to control the app&amp;rsquo;s access to specific mailboxes. You will add the user account for each mailbox the app needs to access as members of the group (including the disabled accounts associated with shared mailboxes).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Create an Application Access Policy: Run the following command to create a policy that restricts the app’s access to the mailboxes within the specified security group&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$appId = &amp;lt;insert clientID of app registration&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$groupId = &amp;lt;insert email address of mail-enabled security group&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>New-ApplicationAccessPolicy -AppId $appId -PolicyScopeGroupId $groupId -AccessRight RestrictAccess -Description &lt;span style="color:#e6db74">&amp;#34;Scopes down appregX to just mailboxes in groupY&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>NOTE: This often takes 1-2 hours to take effect once created&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>As you can see, the restriction is actually behing handled by Exchange so the app still has the broad permissions that were originally requested but in practice it will get an &amp;ldquo;Access Denied&amp;rdquo; if it tries to access any mailbox that is not in the group. By using this policy, you can ensure that your application only accesses the mailboxes that are explicitly needed, improving your organization’s security and compliance posture.&lt;/p>
&lt;h3 id="restricting-app-access-to-teamssharepoint-online-site-collections">Restricting App Access to Teams/SharePoint Online Site Collections&lt;/h3>
&lt;p>As mentioned previously, granting application permissions for SPO/Teams via Microsoft Graph was an all-or-nothing proposition, with apps having access to all site collections within a tenant. However, Microsoft has introduced a new permission called &lt;code>Sites.Selected&lt;/code>, which allows administrators to limit app access to specific site collections. Unlike the access policy outlined above, this is done within MS Graph itself by replacing the requested &lt;code>Sites.Read.All&lt;/code> or &lt;code>Sites.ReadWrite.All&lt;/code> permissions with the &lt;code>Sites.Selected&lt;/code> instead.&lt;/p>
&lt;h4 id="steps-to-configure-access">Steps to Configure Access:&lt;/h4>
&lt;p>While technically granting your application access to a particular site collection only requires a single API call, there&amp;rsquo;s a process that you&amp;rsquo;ll need to follow in order to accomplish that call:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Assign the &lt;code>Sites.Selected&lt;/code> Permission&lt;/strong>:
Begin by assigning the &lt;code>Sites.Selected&lt;/code> permission to your application. This can be done in the EntraID app registration portal. By default, this permission does &lt;strong>NOT&lt;/strong> grant access to any site collections.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Create/use an app registration that has &lt;code>Sites.FullControl.All&lt;/code> (appregA)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>This will be used to APPLY the permission to the restricted app registration&lt;/li>
&lt;li>A temporary app registration can be created for this as long as it is deleted afterwards&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Create/identify an app registration that has Sites.Selected (appregB)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>This will be granted the API permission to the targeted Teams/SPO site(s)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>API call to output an access token for appregA&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Type: &lt;code>POST&lt;/code>&lt;/li>
&lt;li>Uri: &lt;code>https://login.microsoftonline.com/&amp;lt;tenantId&amp;gt;/oauth2/v2.0/token&lt;/code>&lt;/li>
&lt;li>Body
&lt;ul>
&lt;li>Grant_Type: &lt;code>client_credentials&lt;/code>&lt;/li>
&lt;li>Scope: &lt;code>https://graph.microsoft.com/.default&lt;/code>&lt;/li>
&lt;li>Client_Id: &lt;code>&amp;lt;clientID fo appregA&amp;gt;&lt;/code>&lt;/li>
&lt;li>Client_Secret: &lt;code>&amp;lt;clientSecret of appregA&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Copy value of &amp;ldquo;access_token&amp;rdquo; in response&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>API call to find &amp;ldquo;siteID&amp;rdquo; of Teams/SPO site(s) wanting to allow an app registration to&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Type: &lt;code>GET&lt;/code>&lt;/li>
&lt;li>Uri: &lt;code>https://graph.microsoft.com/v1.0/sites/uticorp.sharepoint.com:/sites/&amp;lt;displayNameOfSite&amp;gt;&lt;/code>&lt;/li>
&lt;li>Authorization: &lt;code>&amp;quot;Bearer &amp;lt;access token for appregA&amp;gt;&amp;quot;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Copy middle value of &amp;ldquo;id&amp;rdquo; in response&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;id&amp;rdquo; in response will contain a comma-separated string and the siteID is the middle value&lt;/li>
&lt;li>Example:&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>API call to apply Teams/SPO site permissions to appregB&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Type: &lt;code>POST&lt;/code>&lt;/li>
&lt;li>Uri: &lt;code>https://graph.microsoft.com/v1.0/sites/&amp;lt;siteID&amp;gt;/permissions&lt;/code>&lt;/li>
&lt;li>Authorization: &lt;code>&amp;quot;Bearer &amp;lt;access token for appregA&amp;gt;&amp;quot;&lt;/code>&lt;/li>
&lt;li>Body:
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;roles&amp;#34;: [&amp;#34;write&amp;#34;],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;grantedToIdentities&amp;#34;: [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;application&amp;#34;: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;id&amp;#34;: &amp;#34;&amp;lt;clientID of appregB&amp;gt;&amp;#34;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#34;displayName&amp;#34;: &amp;#34;&amp;lt;DisplayName of appregB&amp;gt;&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>Insert the clientID and DisplayName of appregB in the above body and the siteID in the Uri with the ID of the site collection you want to grant access to. Microsoft provides the following roles:
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Role Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>read&lt;/td>
&lt;td>Read-only&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>write&lt;/td>
&lt;td>Adds Write and related bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>manage&lt;/td>
&lt;td>Adds Manage Lists / Designer and related bits&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fullcontrol&lt;/td>
&lt;td>All permissions&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>If access to more than one site is needed, just call the permissions endpoint for each site and respective role the app registration needs.&lt;/p>
&lt;p>While obviously this is more cumbersome than granting the originally requested permission, this approach provides a more secure method of managing application permissions, ensuring that apps only interact with specific site collections, thus reducing the risk of unauthorized access.&lt;/p>
&lt;h3 id="examples">Examples&lt;/h3>
&lt;p>&lt;img src="https://adminbraindump.com/post/restrict-graph-api/getBearerToken.png"
width="720"
height="636"
srcset="https://adminbraindump.com/post/restrict-graph-api/getBearerToken_hu5458827622032969681.png 480w, https://adminbraindump.com/post/restrict-graph-api/getBearerToken_hu10630132615768919918.png 1024w"
loading="lazy"
alt="Get Bearer Token"
class="gallery-image"
data-flex-grow="113"
data-flex-basis="271px"
>
&lt;img src="https://adminbraindump.com/post/restrict-graph-api/getSiteID.png"
width="720"
height="531"
srcset="https://adminbraindump.com/post/restrict-graph-api/getSiteID_hu17229586570458206775.png 480w, https://adminbraindump.com/post/restrict-graph-api/getSiteID_hu13577386426811082080.png 1024w"
loading="lazy"
alt="Get siteID"
class="gallery-image"
data-flex-grow="135"
data-flex-basis="325px"
>
&lt;img src="https://adminbraindump.com/post/restrict-graph-api/emailFailing.png"
width="1131"
height="365"
srcset="https://adminbraindump.com/post/restrict-graph-api/emailFailing_hu1608701126365362989.png 480w, https://adminbraindump.com/post/restrict-graph-api/emailFailing_hu18090683315262391397.png 1024w"
loading="lazy"
alt="Email Failing Properly"
class="gallery-image"
data-flex-grow="309"
data-flex-basis="743px"
>
&lt;img src="https://adminbraindump.com/post/restrict-graph-api/emailWorking.png"
width="1081"
height="551"
srcset="https://adminbraindump.com/post/restrict-graph-api/emailWorking_hu12642075313533132518.png 480w, https://adminbraindump.com/post/restrict-graph-api/emailWorking_hu17732853269987000793.png 1024w"
loading="lazy"
alt="Email Working"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="470px"
>
&lt;img src="https://adminbraindump.com/post/restrict-graph-api/teamsFailing.png"
width="948"
height="475"
srcset="https://adminbraindump.com/post/restrict-graph-api/teamsFailing_hu17249025439854996100.png 480w, https://adminbraindump.com/post/restrict-graph-api/teamsFailing_hu9077682590099019477.png 1024w"
loading="lazy"
alt="Teams/SPO Failing Properly"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="478px"
>
&lt;img src="https://adminbraindump.com/post/restrict-graph-api/teamsWorking.png"
width="1059"
height="532"
srcset="https://adminbraindump.com/post/restrict-graph-api/teamsWorking_hu4582836064697577380.png 480w, https://adminbraindump.com/post/restrict-graph-api/teamsWorking_hu18077073963194081764.png 1024w"
loading="lazy"
alt="Teams Working"
class="gallery-image"
data-flex-grow="199"
data-flex-basis="477px"
>&lt;/p></description></item><item><title>Create AzureAD Guest Users with Additional Attributes using MS Graph</title><link>https://adminbraindump.com/post/azuread-guest-users/</link><pubDate>Sun, 27 Aug 2023 09:00:50 -0700</pubDate><guid>https://adminbraindump.com/post/azuread-guest-users/</guid><description>&lt;h5 id="update-011024">Update 01/10/24&lt;/h5>
&lt;p>Microsoft currently has a feature called &lt;a class="link" href="https://learn.microsoft.com/en-us/entra/identity/multi-tenant-organizations/multi-tenant-organization-overview" target="_blank" rel="noopener"
>Multi-tenant Organization (MTO)&lt;/a> in public preview that manages the creation, enable/disabling, and deletion of Guest accounts between different tenants. Microsoft advertises an improved collaborative experience when working with users from the other organization &lt;del>but, so far in my experience, while the automatic sync/management of Guest accounts is a plus - the collaborative experience is actually worse once MTO is involved.&lt;/del>&lt;/p>
&lt;h5 id="update-031624">Update 03/16/24&lt;/h5>
&lt;p>While MTO is still in preview, Microsoft has made great strides towards what I would consider a feature that is close to GA-ready. I have now been using MTO to sync roughly 5,000 total users between two tenants and despite some initial rockiness it has been smooth for the better part of 60 days. For end-users to be able to find each other in the GAL has been a widely praised feature and being able to leverage SSO configurations via Enterprise App means to allow users from the other tenant to SSO into a SaaS application now only requires a few minutes of effort rather than configuring SSO from scratch again (or worse, finding that the SaaS vendor only supports a single IdP). At the time of this writing, I would recommend MTO for any M&amp;amp;A scenario where users need to collaborate within MS Teams or access shared SaaS applications.&lt;/p>
&lt;h2 id="original-post">Original post&lt;/h2>
&lt;p>Over the last decade or so, Microsoft has done a terrible job at addressing needs for Mergers and Acquisitions of medium to large businesses. They have provided almost no tooling and the features that exist often fall short of being production worthy in an M&amp;amp;A scenario. In many of these scenarios, there is often a business need to get the staff of a newly acquired company to access the parent company&amp;rsquo;s existing platforms (HRIS, ERP, etc). For this, using AzureAD Guest accounts can often provide this access without having to complete a full identity migration of those users into the parent tenant.&lt;/p>
&lt;p>AzureAD (aka EntraID) B2B/Guest user accounts are a very powerful and flexible way to grant individuals outside of your primary tenant access to things as if they are within your tenant. A great example of this is Single SignOn (SSO) access to a third party SaaS application that you need contractors, or users from a newly acquired business, to access. Unfortunately (at the time of writing), even using the most modern methods for creating Guest Users like leveraging MS Graph does not allow for many attributes of a user account to be set at the time of creation; even attributes as basic as First Name or Last Name. These attributes are often passed through SSO configurations, like SAML or OIDC, as claims and are required for these Guest Users to be able to authenticate through SSO. Until Microsoft addresses this, the best course of action is to create all of the Guest Accounts and then take another pass through them to apply the necessary attributes. I recently had this scenario play out after my company acquired another and we needed all of their hiring managers and recruiters (about 300 in total) to access our SaaS recruiting platform. In this post, we will go over a script I wrote to handle all of the steps needed to complete this process.&lt;/p>
&lt;h3 id="prerequisites">Prerequisites&lt;/h3>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.powershellgallery.com/packages/Microsoft.Graph" target="_blank" rel="noopener"
>Microsoft Graph Powershell Module&lt;/a>&lt;/li>
&lt;li>AzureAD (EntraID) subscription&lt;/li>
&lt;li>Graph API permissions for &lt;code>User.Invite.All&lt;/code>,&lt;code>User.ReadWrite.All&lt;/code>, and &lt;code>Directory.ReadWrite.All&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="ingest-list-of-users">Ingest list of users&lt;/h3>
&lt;p>The first thing I had the other company provide me was a CSV that contains the three key pieces of information we needed to for each user: FirstName, LastName, and EmailAddress. When I received it, I noticed that the FirstName was in all caps but for cleanliness&amp;rsquo; sake I didn&amp;rsquo;t want these Guest Users to have names in all caps; we&amp;rsquo;ll address this later in the script. (If you&amp;rsquo;re ever sending data to be used programmatically, please don&amp;rsquo;t be &amp;ldquo;that guy&amp;rdquo;; make sure the formatting is decent)&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/azuread-guest-users/Import-Csv.png"
width="418"
height="295"
srcset="https://adminbraindump.com/post/azuread-guest-users/Import-Csv_hu2415264789609545984.png 480w, https://adminbraindump.com/post/azuread-guest-users/Import-Csv_hu8417695367970960552.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="340px"
>&lt;/p>
&lt;h3 id="connect-to-ms-graph">Connect to MS Graph&lt;/h3>
&lt;p>Connecting to MS Graph using the Powershell module is pretty straight forward: &lt;code>Connect-MgGraph&lt;/code>. One thing people tend to forget is to identify the permissions ahead of time that you&amp;rsquo;ll need in order to perform the tasks at hand. For this, we will need &lt;code>User.Invite.All&lt;/code>,&lt;code>User.ReadWrite.All&lt;/code>, and &lt;code>Directory.ReadWrite.All&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/azuread-guest-users/Connect.png"
width="965"
height="223"
srcset="https://adminbraindump.com/post/azuread-guest-users/Connect_hu6212128955751733444.png 480w, https://adminbraindump.com/post/azuread-guest-users/Connect_hu5430135240932876252.png 1024w"
loading="lazy"
alt="Is anyone else tired of these &amp;ldquo;welcome messages&amp;rdquo; in Powershell modules?"
class="gallery-image"
data-flex-grow="432"
data-flex-basis="1038px"
>&lt;/p>
&lt;h3 id="declare-variables">Declare variables&lt;/h3>
&lt;p>For SSO configurations, I always lock down the AzureAD Enterprise App to only allow authentication for users in a particular Security Group. One thing to note here is that Guest Users can ONLY be added to a cloud security group and CANNOT be added to a security group that has been synced up from OnPrem AD via AzureAD Connect. Adding these Guest Users to this cloud group is what grants them the ability within AzureAD to authenticate against the Enterprise App and SSO. There&amp;rsquo;s a few ways to grab this group using &lt;code>Get-MgGroup&lt;/code> but I&amp;rsquo;ve found searching by display name to be the most convenient; in this case the group is &amp;lsquo;ASG_demo_sso_guests.&amp;rsquo; We&amp;rsquo;re setting &lt;code>$i&lt;/code> to 0 now so we can use it as a counter to output the total number of Guest Users created.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/azuread-guest-users/variables.png"
width="1028"
height="41"
srcset="https://adminbraindump.com/post/azuread-guest-users/variables_hu16767548113899453257.png 480w, https://adminbraindump.com/post/azuread-guest-users/variables_hu16478814754036374529.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="2507"
data-flex-basis="6017px"
>&lt;/p>
&lt;h3 id="creating-the-guest-users">Creating the Guest Users&lt;/h3>
&lt;p>Guest user accounts are created by what MS calls an &amp;ldquo;Invitation.&amp;rdquo; The default behavior when creating these is to send out an email invite that the user interacts with to accept. In most cases, this email causes confusion and generates helpdesk calls so I typically suppress it with &lt;code>-SendInvitationMessage:$false&lt;/code>. As mentioned above, the CSV that was provided had users&amp;rsquo; first names in all caps but ideally users would have the first letter of each name capitalized. To fix this before creating the users, we leverage the &lt;code>ToTitleCase&lt;/code> method of the &lt;code>Get-Culture&lt;/code> cmdlet; this will capitalize the first letter lowercase the rest. I know this works well when location is set to US but I have not tested it outside of that. One nuance of &lt;code>ToTitleCase&lt;/code> is that it assumes anything that is all caps is an acronym and doesn&amp;rsquo;t change any of the casing. Since the first names in our CSV are all caps, we can get around this by converting the names to all lowercase while pulling them into &lt;code>ToTitleCase&lt;/code>. The below foreach loop will confirm that a Guest User does not already exist for the email address then create a Guest User with the email address while converting the casing of the First and Last names to create the DisplayName (backticks used for formatting).&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/azuread-guest-users/createGuests.png"
width="1131"
height="289"
srcset="https://adminbraindump.com/post/azuread-guest-users/createGuests_hu350930896096550809.png 480w, https://adminbraindump.com/post/azuread-guest-users/createGuests_hu8179151544821243949.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="391"
data-flex-basis="939px"
>&lt;/p>
&lt;h3 id="optional-while-loop">Optional: While Loop&lt;/h3>
&lt;p>My experience has been that the time it takes for Guest Users to be created and available to make changes to varies pretty widely. I&amp;rsquo;ve seen them be available near-instant and I&amp;rsquo;ve seen them take 5-10 minutes. Personally, I did not include a &lt;code>While&lt;/code> loop in my script to avoid it taking an extremely long time to complete but if you want a single repeatable script for creating Guest Users I would recommend one. As an example, here&amp;rsquo;s one that will check for the existance of the Guest User account but, importantly, give up after 60 seconds.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/azuread-guest-users/whileLoop.png"
width="903"
height="77"
srcset="https://adminbraindump.com/post/azuread-guest-users/whileLoop_hu16059215968782484945.png 480w, https://adminbraindump.com/post/azuread-guest-users/whileLoop_hu2654242581504680889.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1172"
data-flex-basis="2814px"
>&lt;/p>
&lt;h3 id="adding-the-additional-attributes-and-other-changes">Adding the additional attributes and other changes&lt;/h3>
&lt;p>Now that the Guest Users exist, adding attributes is relatively simple and straight forward. Since we are making multiple changes to every user on this list (setting FirstName, setting LastName, and adding user to the security group), we will make all the changes as part of a single &lt;code>foreach&lt;/code> loop. One thing to note is that while earlier we ensured to only attempt to create a Guest User if one didn&amp;rsquo;t already exist, we want to make these next changes to every Guest User in the CSV, regardless of whether it existed prior. However, we also want to make sure that an output exists for any failures so we are made aware. Granted, since we&amp;rsquo;re using the same CSV there should be no failures, but it&amp;rsquo;s always good to throw in an extra line or two that helps the confidence of the script output.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/azuread-guest-users/setAttributes.png"
width="820"
height="287"
srcset="https://adminbraindump.com/post/azuread-guest-users/setAttributes_hu15760581013605393147.png 480w, https://adminbraindump.com/post/azuread-guest-users/setAttributes_hu4543309082533388470.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="285"
data-flex-basis="685px"
>&lt;/p>
&lt;h3 id="put-it-all-together">Put it all together&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>$csv = Import-Csv -Path &amp;lt;path to csv&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connect-MgGraph -Scopes User.Invite.All,User.ReadWrite.All,Directory.ReadWrite.All
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$group = Get-MgGroup -Search &lt;span style="color:#e6db74">&amp;#34;DisplayName:ASG_demo_sso_guests&amp;#34;&lt;/span> -ConsistencyLevel eventual
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$i = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">foreach&lt;/span> ($guest &lt;span style="color:#66d9ef">in&lt;/span> $csv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $user = Get-MgUser -Search &lt;span style="color:#e6db74">&amp;#34;mail:&lt;/span>$($guest.EmailAddress)&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -ConsistencyLevel eventual -ea SilentlyContinue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!($user)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> New-MgInvitation `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -InvitedUserEmailAddress $($guest.EmailAddress) `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -InviteRedirectUrl &lt;span style="color:#e6db74">&amp;#34;https://portal.office.com&amp;#34;&lt;/span> `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -InvitedUserDisplayName (Get-Culture).TextInfo.ToTitleCase(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$($guest.FirstName.toLower())&lt;span style="color:#e6db74"> &lt;/span>$($guest.LastName.ToLower())&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -SendInvitationMessage:$false `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | Out-Null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $i++
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Clear-Variable user
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Write-Output &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$i&lt;span style="color:#e6db74"> guest users created&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;# OPTIONAL to be incorporated in the foreach loop
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">$date = Get-Date
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">while (($null -eq $GuestUser) -and ((Get-Date) -le $date.AddSeconds(60))) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> $GuestUser = Get-MgUser -Search &amp;#34;mail:$($guest.EmailAddress)&amp;#34; -ConsistencyLevel eventual
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> Start-Sleep -Seconds 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">foreach&lt;/span> ($guest &lt;span style="color:#66d9ef">in&lt;/span> $csv) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ($user) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Clear-Variable user
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $user = Get-MgUser -Search &lt;span style="color:#e6db74">&amp;#34;mail:&lt;/span>$($guest.EmailAddress)&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -ConsistencyLevel eventual
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ($user) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Update-MgUser `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -UserId $user.Id `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -GivenName (Get-Culture).TextInfo.ToTitleCase($($guest.FirstName.toLower())) `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -Surname (Get-Culture).TextInfo.ToTitleCase($($guest.LastName.toLower()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> New-MgGroupMember -GroupId $group.id -DirectoryObjectId $user.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Write-Output &lt;span style="color:#e6db74">&amp;#34;Unable to find account with email &lt;/span>$($guest.EmailAddress)&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Properly and Fully Delete Windows User Profile</title><link>https://adminbraindump.com/post/delete-windows-user-profile/</link><pubDate>Tue, 31 Jan 2023 07:57:19 -0700</pubDate><guid>https://adminbraindump.com/post/delete-windows-user-profile/</guid><description>&lt;p>Recently, while investigating a &amp;ldquo;Low Free Space on C: Volume&amp;rdquo; alert on one of our servers I took a look at the &lt;code>C:\Users&lt;/code> folder and noticed a user profile folder for a sysadmin that hadn&amp;rsquo;t worked for the company in over 10 years. I mentioned this to a coworker who said, &amp;ldquo;Yeah I used to look at &lt;code>C:\Users&lt;/code> on all the servers and delete that folder if I saw it but I kind of gave up after a while.&amp;rdquo; If you&amp;rsquo;ve tried this you likely have found that it takes Windows quite a while to delete all the system files, etc. inside that profile folder and can often run into weird NTFS permission issues, or the cursed Thumbs.db &amp;ldquo;in use by another program&amp;rdquo; annoyance.&lt;/p>
&lt;p>Whatever the reason you may have for deleting the user profile from a Windows Server (or workstation), deleting that folder is not even fully removing the user profile from the machine, leaving registry keys and other references to that profile strewn about the OS. The better way to do this is to use Powershell to leverage CIM (Common Information Model) and remove the entire profile, which includes that folder, quickly and easily.&lt;/p>
&lt;h3 id="nuke-the-profile">Nuke the profile&lt;/h3>
&lt;p>For my use case, I wanted to cycle through our hundreds of servers to remove this old profile (and a couple others that I knew were floating around out there) from every single one. My first step is to gather a list of just the name of all those servers. Every environment is different but the most generic way to grab all Windows Server names out of Active Directory is by filtering the &lt;code>Get-ADComputer&lt;/code> cmdlet.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Replace &amp;#39;username&amp;#39; below with the name of the target folder in C:\Users&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$servers = (Get-ADComputer -Filter {operatingSystem &lt;span style="color:#f92672">-like&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*Windows Server*&amp;#34;&lt;/span>}).Name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$username = &lt;span style="color:#e6db74">&amp;#34;username&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once we have all server names and our target username, we can take advantage of the fact that the &lt;code>Get-CimInstance&lt;/code> cmdlet&amp;rsquo;s parameter &lt;code>-ComputerName&lt;/code> accepts an array of strings (which our $servers variable from above will be). As a result, we won&amp;rsquo;t need a foreach loop, or to push this out as jobs, it&amp;rsquo;s a simple one-liner pipeline to do the rest:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Get-CimInstance -ComputerName $servers -ClassName Win32_UserProfile | Where-Object {$_.localpath &lt;span style="color:#f92672">-like&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*&lt;/span>$username&lt;span style="color:#e6db74">&amp;#34;&lt;/span>} | Remove-CimInstance
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s it! This will go through all servers and remove all references to the user profile, including the profile folder, that match that username. In my environment it took less time for this to run through hundreds of servers than it took for a single user profile folder to be deleted in File Explorer, so in this case doing things the proper way also ended up being the easy way. Win-Win!&lt;/p></description></item><item><title>Find Created/Modified Date of Active Directory DNS Object</title><link>https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/</link><pubDate>Thu, 22 Sep 2022 16:06:33 -0700</pubDate><guid>https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/</guid><description>&lt;p>Be honest, your onprem DNS is probably a bit of a mess. I&amp;rsquo;ve yet to encounter an organization that doesn&amp;rsquo;t have old/stale records in their onprem Active Directory integrated DNS; even when DNS scavenging is enabled. Sometimes this is a lack of time spent on housekeeping within DNS (&lt;em>raises hand&lt;/em>: &amp;ldquo;guilty!&amp;rdquo;), other times it&amp;rsquo;s because nobody is quite sure how long that DNS record has been around to identify whether it can be deleted or not. We can use Powershell to identify DNS records &lt;code>Created&lt;/code> and/or &lt;code>Modified&lt;/code> date to help answer some questions about whether it can be deleted. However, the traditional DNS Powershell cmdlets (&lt;code>Get-DnsServerResourceRecord&lt;/code>, etc.) will not output any information regarding &lt;code>Created&lt;/code> or &lt;code>Modified&lt;/code>. Instead, we will leverage the Active Directory database behind the scenes to get these attributes.&lt;/p>
&lt;h3 id="finding-specific-dns-objects">Finding specific DNS objects&lt;/h3>
&lt;p>By default when the Active Directory Powershell Module is installed/imported (either on a Domain Controller or when RSAT Tools are installed), Powershell recognizes &amp;ldquo;AD:&amp;rdquo; as a valid drive and this can be used to browse the AD database. To see the different drives that Powershell will recognize, run &lt;code>Get-PSDrive&lt;/code>.&lt;br>
&lt;img src="https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/get-psdrive.png"
width="580"
height="248"
srcset="https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/get-psdrive_hu231251180814885746.png 480w, https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/get-psdrive_hu5633721556932659575.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="561px"
>&lt;/p>
&lt;p>We can use &lt;code>Get-ChildItem&lt;/code> to iterate through objects in this &amp;ldquo;drive&amp;rdquo; and output attributes of those objects; including the &lt;code>Created&lt;/code> and &lt;code>Modified&lt;/code> attributes. Typically, &lt;code>Get-ChildItem&lt;/code> is used in conjuction with File Systems (network drives, local drives, etc.) so under common cirumstances I would &lt;a class="link" href="https://adminbraindump.com/post/improve-powershell-runtimes-using-filter-parameter/" >always recommend using the &lt;code>-Filter&lt;/code> parameter&lt;/a> for that cmdlet when trying to grab specific objects; this cuts WAY down on the amount of time it takes an object to be returned. However, per &lt;a class="link" href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem?view=powershell-7.2#-filter" target="_blank" rel="noopener"
>Microsoft Documentation for that parameter&lt;/a>, &lt;em>&amp;ldquo;The FileSystem provider is the only installed Powershell provider that supports filters.&amp;rdquo;&lt;/em> As you can see below, our AD: drive does not have a &lt;code>Provider&lt;/code> of FileSystem, so we cannot use the &lt;code>-Filter&lt;/code> parameter for this. My DNS environment has a little over 11,000 records so it&amp;rsquo;s not a huge loss, but for extremely large environments it could hurt.
&lt;img src="https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/get-psdrive-filesystem.png"
width="580"
height="248"
srcset="https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/get-psdrive-filesystem_hu12293064959759143855.png 480w, https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/get-psdrive-filesystem_hu1280003470031731023.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="233"
data-flex-basis="561px"
>&lt;/p>
&lt;p>Assuming that we&amp;rsquo;re not looking to output all records (scroll down for more on that), we can leverage &lt;code>Where-Object&lt;/code> to only output the objects based on the criteria we want. For this, we specify the path of our &lt;code>Get-ChildItem&lt;/code> function to the DNS path inside the aforementioned AD &amp;ldquo;drive,&amp;rdquo; pipe that to &lt;code>Where-Object&lt;/code> to specify the criteria we&amp;rsquo;re looking for (in this case &amp;ldquo;Name&amp;rdquo;), then pipe that to Get-ADObject to output the &lt;code>Created&lt;/code> and &lt;code>Modified&lt;/code> attributes of that object in the AD database.&lt;br>
&lt;img src="https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/where-object.png"
width="858"
height="118"
srcset="https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/where-object_hu8490985256552420473.png 480w, https://adminbraindump.com/post/find-created-modified-date-of-active-directory-dns-object/where-object_hu5979261814390794063.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="727"
data-flex-basis="1745px"
>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Get-ChildItem -Path &lt;span style="color:#e6db74">&amp;#34;AD:DC=domain.com,CN=MicrosoftDNS,CN=System,DC=domain,DC=com&amp;#34;&lt;/span> | Where-Object {$_.Name &lt;span style="color:#f92672">-eq&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;lt;record name&amp;gt;&amp;#34;&lt;/span>} | Get-ADObject -Properties Created,Modified | Select-Object Name,Created,Modified
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#or&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Get-ChildItem -Path &lt;span style="color:#e6db74">&amp;#34;AD:DC=domain.com,CN=MicrosoftDNS,CN=System,DC=domain,DC=com&amp;#34;&lt;/span> | Where-Object {$_.Name &lt;span style="color:#f92672">-like&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*&amp;lt;keyword&amp;gt;*&amp;#34;&lt;/span>} | Get-ADObject -Properties Created,Modified | Select-Object Name,Created,Modified
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="output-all-dns-objects">Output all DNS objects&lt;/h3>
&lt;p>If you want to output the created and/or modified date of every DNS object in the AD environment just remove the &lt;code>Where-Object&lt;/code> function from the pipeline. Given how many objects are likely going to be returned, you will likely want to pipe that to &lt;code>Export-Csv&lt;/code> to ensure that you have a readable file rather than having it all dump to the Powershell console.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Get-ChildItem -Path &lt;span style="color:#e6db74">&amp;#34;AD:DC=domain.com,CN=MicrosoftDNS,CN=System,DC=domain,DC=com&amp;#34;&lt;/span> | Get-ADObject -Properties Created,Modified | Select-Object Name,Created,Modified | Export-Csv -Path $env:USERPROFILE\Downloads\AD_DNS.csv -NoTypeInformation
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Improve Powershell Runtimes Using the Filter Parameter</title><link>https://adminbraindump.com/post/improve-powershell-runtimes-using-filter-parameter/</link><pubDate>Thu, 22 Sep 2022 15:16:18 -0700</pubDate><guid>https://adminbraindump.com/post/improve-powershell-runtimes-using-filter-parameter/</guid><description>&lt;p>When working with larger datasets in Powershell it can take a while to output the data that you want. One of the first concepts Powershell users learn is the use of the &lt;code>Where-Object&lt;/code> function to pipe data in and limit the output to just the data they are looking for. When working with small datasets, this works totally fine and is widely used. One important nuance of this function, though, is that it needs to wait for all of the data to be piped into it first, then it identifies the objects that match the criteria, and then finally outputs those objects. With larger datasets this can end up taking an extremely long time and if we&amp;rsquo;re only looking for a specific object or set of objects we can drastically reduce the time it takes to output what we want if we instead use the &lt;code>-Filter&lt;/code> parameter of functions that support it.&lt;/p>
&lt;p>As an example, you can see below that there are 351,497 items underneath C:\Windows. If we use &lt;code>Get-ChildItem&lt;/code> and were to try to output only a single file named &amp;ldquo;wlidsvcconfig.xml&amp;rdquo; using &lt;code>Where-Object&lt;/code> it has to wait for all 351,497 of those objects to be passed through the pipeline before it can output the file we&amp;rsquo;re looking for. If we use &lt;code>-Filter&lt;/code> then the function will only get objects that match the filter criteria and then pass those through the pipeline. There is still computational load to identify the objects that match the criteria, but at scale it is always going to be significantly less than waiting for all of the objects to be returned first and then having &lt;code>Where-Object&lt;/code> look at them. Using this example, it takes less than half the time (27.76 seconds versus 66.86 seconds) to accomplish the same thing.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/improve-powershell-runtimes-using-filter-parameter/filter-measure.png"
width="962"
height="297"
srcset="https://adminbraindump.com/post/improve-powershell-runtimes-using-filter-parameter/filter-measure_hu11506036472792225822.png 480w, https://adminbraindump.com/post/improve-powershell-runtimes-using-filter-parameter/filter-measure_hu6209414031541717591.png 1024w"
loading="lazy"
alt="Filter parameter takes roughly half as long as Where-Object"
class="gallery-image"
data-flex-grow="323"
data-flex-basis="777px"
>&lt;/p></description></item><item><title>Protect Passwords in Powershell Scripts</title><link>https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/</link><pubDate>Sat, 17 Sep 2022 08:51:50 -0700</pubDate><guid>https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/</guid><description>&lt;p>In light of the recent news that &lt;a class="link" href="https://arstechnica.com/information-technology/2022/09/uber-was-hacked-to-its-core-purportedly-by-an-18-year-old-here-are-the-basics/" target="_blank" rel="noopener"
>Uber was hacked&lt;/a> largely in part due to a highly privileged credentials being stored in a Powershell script in plain text, I figured some admins writing Powershell might be scrambling to finally level up their secret game. There are lots of ways to store your credentials for Powershell scripts (and effectively &lt;em>all&lt;/em> of them are better than plain text); each with their own list of pros and cons, but I&amp;rsquo;ll share one way that provides a layered approach to protecting the secrets while also the flexibility to use those secrets on-prem or in the cloud.&lt;/p>
&lt;h3 id="prerequisites">Prerequisites&lt;/h3>
&lt;ul>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-8.3.0" target="_blank" rel="noopener"
>Azure Az Powershell Module&lt;/a>&lt;/li>
&lt;li>Azure subscription&lt;/li>
&lt;li>Access to create Azure KeyVault and grant access controls to it&lt;/li>
&lt;li>Access to create AzureAD Service Principals (App registration)&lt;/li>
&lt;/ul>
&lt;h3 id="store-the-actual-secrets-in-azure-keyvault">Store the actual secrets in Azure KeyVault&lt;/h3>
&lt;p>The actual usernames/passwords needed by the script to perform operations will be stored in Azure KeyVault. This allows for granular/RBAC permissions to be granted to secrets within Azure as well as a way to separate the credentials so scripts do not have access to more than they need. Anytime you are creating a new workload, function, group of tasks, etc. I recommend to put them in their own resource group. This helps organize things but also helps with applying specific Azure Policy to specific resources. In this example, I create a new resource group and then a new KeyVault to be used for these secrets.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/create-rg-and-kv.png"
width="1470"
height="538"
srcset="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/create-rg-and-kv_hu3820445918062874528.png 480w, https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/create-rg-and-kv_hu15177147663029245981.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="655px"
>&lt;/p>
&lt;h3 id="create-a-service-principal">Create a Service Principal&lt;/h3>
&lt;p>Now that the KeyVault exists we need to limit who can access the secrets inside. For this we will be creating a service principal by way of an Azure App registration. The naming convention you use for app registrations may vary, the important part here is to differentiate between scripts as each script/task will have it&amp;rsquo;s own Service Principal. Doing so ensures that each script has it&amp;rsquo;s own individual authentication mechanism so logs will clearly indicate which process was authenticating. At this point, you may be thinking that it would be convenient to have one KeyVault with all of your credentials in it and then limit Service Principals to only being able to read the credentials they need. Sadly, Microsoft does not provide a way to set permissison on individaul keys or secrets within a KeyVault; only to the KeyVault itself. As a result, we create a separate KeyVault for each script (though we can keep them all in one Resource Group). We do this so if somehow the service principal was ever compromised that it does not hold the keys to the kingdom, only to the couple of secrets it needs to run and only the ability to read that secret, not modify/delete. Does this make it a pain when we rotate/change passwords? Absolutely, but doing things the &amp;ldquo;right&amp;rdquo; way is typically a pain when compared to the alternative.&lt;/p>
&lt;p>Create a new Service Principal and note the &lt;code>AppId&lt;/code> output. Then, create a new KeyVault Access Policy that grants &amp;ldquo;get&amp;rdquo; permissions for secrets in the desired KeyVault using the aforementioned &lt;code>AppId&lt;/code> value for the &lt;code>ServicePrincipalName&lt;/code> parameter. This value can also be found for existing Service Principals by looking at the &lt;code>AppId&lt;/code> or &lt;code>ServicePrincipalName&lt;/code> attributes of that object using &lt;code>Get-AzADServicePrincipal&lt;/code> cmdlet.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/create-serviceprincipal-and-accesspolicy.png"
width="1477"
height="254"
srcset="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/create-serviceprincipal-and-accesspolicy_hu5135643034340222724.png 480w, https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/create-serviceprincipal-and-accesspolicy_hu9232045373104042653.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="581"
data-flex-basis="1395px"
>&lt;/p>
&lt;h3 id="create-a-client-secret">Create a Client Secret&lt;/h3>
&lt;p>The Service Principal now has access to the KeyVault, however we still need a way to use (authenticate as) the Service Principal. Azure automatically creates a Client Secret when you create a new Service Principal. However, when you create it via Powershell you are not presented with what that Client Secret is, and by design you can never recover it again. As a result, I make it a habit to just delete the one Azure creates immediately after I create a Service Principal and create a new one. Because Client Secrets cannot be accessed ever again once they&amp;rsquo;re created, it&amp;rsquo;s important that you account for this when building a new one. As you can see in the example below if you just create a new Secret the &lt;code>SecretText&lt;/code> attribute can actually be truncated in your Powershell console and you will not be able to get the full value ever again. As a result, if you are building this interactively be sure to either encase the command in parenthesis and call the &lt;code>SecretText&lt;/code> attribute, or use &lt;code>Select-Object&lt;/code> to expand the property (my preference).&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/secret-text-attribute.png"
width="1508"
height="375"
srcset="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/secret-text-attribute_hu16889591214168014300.png 480w, https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/secret-text-attribute_hu14573753585361021943.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="402"
data-flex-basis="965px"
>&lt;/p>
&lt;h3 id="connection-in-powershell-script">Connection in Powershell Script&lt;/h3>
&lt;p>Now all that is left is to tell our Powershell script to authenticate into the Azure tenant AS that Service Principal and then access the Secret in that KeyVault. The first step for this is to obtain the Tenant ID if you don&amp;rsquo;t already have it. The easiest way to do this is when connected to Azure via Powershell just run &lt;code>(Get-AzContext).tenant.id&lt;/code> and it will return the ID you need. Once you have this, you connect using the method below by using your Service Principal Name (aka &lt;code>AppId&lt;/code>, or &lt;code>ClientID&lt;/code>) and the Client Secret. The first line shows that I am not connected to the tenant and the last line shows the that I was able to output the secret in plain text after authenticating as the Service Principal.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/connect-sp-output-secret.png"
width="1508"
height="498"
srcset="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/connect-sp-output-secret_hu7888832801132241309.png 480w, https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/connect-sp-output-secret_hu12661364918043197875.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="302"
data-flex-basis="726px"
>&lt;/p>
&lt;h3 id="whats-the-difference">What&amp;rsquo;s the difference?&lt;/h3>
&lt;p>Great, so we now have the ability to let our Powershell scripts authenticate to Azure KeyVault to obtain passwords and secrets. But as many people tend to point out at this stage, aren&amp;rsquo;t we just putting the &amp;ldquo;Client Secret&amp;rdquo; in plain text in the script? And isn&amp;rsquo;t that basically just a password as well? Yes and yes. While keeping the password itself out of plain text and in Azure KeyVault instead is definitely more secure, it&amp;rsquo;s just a small hurdle for an attacker to jump through to get the password. The second step here is what helps lock this down in a much more secure way: Encrypting the client secret in a local file on the server running the Powershell script. This is done by leveraging the Data Protection API (DPAPI) built into the Windows Server OS. When this API is used to encrypt a file there are two key requirements that must be met to decrypt the file that we take advantage of:&lt;/p>
&lt;ol>
&lt;li>The decryption request must come from the user account that was used to originally encrypt it.&lt;/li>
&lt;li>The decryption request must come from the Windows Server OS that was used to originally encrypt it.&lt;/li>
&lt;/ol>
&lt;p>This means that if an attacker were able identify that this file holds the Client Secret (let&amp;rsquo;s say by locating the Powershell script and seeing a connection string like in the case of Uber&amp;rsquo;s hack), they could not decrypt the file unless they were logged into the server that originally encrypted the file and ALSO logged in as the user that originally encrypted the file. The catch here is that you must run the scheduled task that is launching the script as the same user that you use to generate the encrypted file; for this use a service account that has no permissions to anything on the network other than the file path it writes this encrypted file to and the location of the script the scheduled task is running.&lt;/p>
&lt;h3 id="encrypting-the-local-file">Encrypting the local file&lt;/h3>
&lt;p>Encrypting data in a local file is quite easy and only takes a couple of lines. First we take the variable we used earlier that is just a plain text string containing the Client Secret; we convert it TO a secure string and then back FROM a secure string and dump that to a text file.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/encrypting-data-to-file.png"
width="1508"
height="109"
srcset="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/encrypting-data-to-file_hu7558720754078577762.png 480w, https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/encrypting-data-to-file_hu8047527722366696499.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1383"
data-flex-basis="3320px"
>&lt;/p>
&lt;h3 id="usingdecrypting-the-local-file">Using/decrypting the local file&lt;/h3>
&lt;p>Rather than go into detail as to how this works, there is a &lt;a class="link" href="https://www.pdq.com/blog/secure-password-with-powershell-encrypting-credentials-part-1/" target="_blank" rel="noopener"
>quick writeup from the folks at PDQ on this topic specifically&lt;/a> that you can read if you&amp;rsquo;re interested. Once the file exists, that is it! It is encrypted by the Windows DP API and decrypting it in scripts (that run as the same user account that encrypted it) is as easy as just &lt;code>Get-Content -Path &amp;lt;path to file&amp;gt; | ConvertTo-SecureString&lt;/code>. As you can see below, if you read the contents of the text file it is just a long string of alphanumeric characters. To make it usable in a script, you just create a credential object using the ClientID and the decrypted Client Secret and use that when connecting to Azure as the Service Principal!&lt;/p>
&lt;p>As the warning in the below screenshot mentions, Microsoft has a pretty idiotic default setting in the &lt;code>Connect-AzAccount&lt;/code> cmdlet in that it saves the secret being used to connect as a service principal&amp;hellip; IN PLAIN TEXT&amp;hellip; in a text file for &amp;ldquo;convenience.&amp;rdquo; I could go on a tirade about why this shouldn&amp;rsquo;t even exist as an option in this first party cmdlet, but to have it function this way by default is abhorrent. Nonetheless, be sure to run &lt;code>Disable-AzContextAutosave&lt;/code> as the service account you use to run the scripts and decrypt the encrypted secret file. Alternatively, you can add &lt;code>Disable-AzContextAutosave -Scope Process&lt;/code> into your script prior to connecting to ensure it never writes the file even if it&amp;rsquo;s moved to another server, the module is updated, etc.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/decrypt-client-secret.png"
width="1498"
height="590"
srcset="https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/decrypt-client-secret_hu5562500267296715362.png 480w, https://adminbraindump.com/post/protect-passwords-in-powershell-scripts/decrypt-client-secret_hu1198030944296372447.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="253"
data-flex-basis="609px"
>&lt;/p></description></item><item><title>Change Friendly Name on Exchange Certificate</title><link>https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/</link><pubDate>Sat, 03 Sep 2022 17:59:38 -0700</pubDate><guid>https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/</guid><description>&lt;p>If you use a wildcard certificate on your onprem Exchange server, it is common that the CSR and certificate are generated outside of the Exchange environment and you are importing it into Exchange. If that&amp;rsquo;s the case, you don&amp;rsquo;t get an option for changing the Friendly Name of the certificate during the import process. This can result in Exchange listing multiple certificates with the same name on the Certificates page in ECP.
&lt;img src="https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/dup-cert-names.png"
width="670"
height="162"
srcset="https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/dup-cert-names_hu16930032222331123481.png 480w, https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/dup-cert-names_hu980941343324211241.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="413"
data-flex-basis="992px"
>&lt;/p>
&lt;h3 id="changing-friendly-name">Changing friendly name&lt;/h3>
&lt;p>You would think that Microsoft would provide an intuitive way to change the friendly name of a certificate either within the ECP web GUI or at least through Powershell cmdlet. Unfortunately, &lt;code>Set-ExchangeCertificate&lt;/code> does not exist and ECP does not give any options to modify the friendly name. Luckily, there is a quick and easy (albeit a bit unintutiive) way to change the friendly name of an Exchange certificate by leveraging a cmdlet that you wouldn&amp;rsquo;t expect to permanently change any attribute: &lt;code>Get-ExchangeCertificate&lt;/code>. To do this, just access the FriendlyName attribute of the certificate in question and set/force the name you want in its place; I name my certificates with the Subject Name followed by the expiry year.
&lt;img src="https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/cert-before-during-after.png"
width="1132"
height="196"
srcset="https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/cert-before-during-after_hu17889878971331820272.png 480w, https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/cert-before-during-after_hu1357510046159153746.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="577"
data-flex-basis="1386px"
>&lt;/p>
&lt;h3 id="alternative-method">Alternative method&lt;/h3>
&lt;p>I have come across a couple scenarios where for some reason the above method didn&amp;rsquo;t work. The command wouldn&amp;rsquo;t output any errors, but the certificate just would not have a different friendly name afterwards. In those few examples, I used a slightly different method to accomplish the same thing. For this, we&amp;rsquo;re effectively doing the same thing but instead of using Exchange, we&amp;rsquo;re just leveraging Powershell&amp;rsquo;s &lt;code>Get-ChildItem&lt;/code> to objectify the certificate we want.
#&lt;img src="https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/cert-gci-before-during-after.png"
width="1164"
height="198"
srcset="https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/cert-gci-before-during-after_hu13921206816634904164.png 480w, https://adminbraindump.com/post/change-friendly-name-on-exchange-certificate/cert-gci-before-during-after_hu4829465532004542034.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="587"
data-flex-basis="1410px"
>&lt;/p>
&lt;p>Keeping clear friendly names will help differentiate certificates no matter how those certificates are being viewed and avoid confusion for others on your team!&lt;/p>
&lt;h3 id="code">Code&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>(Get-ExchangeCertificate -Thumbprint &lt;span style="color:#e6db74">&amp;#34;&amp;lt;thumbprint&amp;gt;&amp;#34;&lt;/span>).FriendlyName = &lt;span style="color:#e6db74">&amp;#39;*.domain.com_2023&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#or&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(Get-ChildItem -Path &lt;span style="color:#e6db74">&amp;#34;Cert:\LocalMachine\my\&amp;lt;thumbprint&amp;gt;&amp;#34;&lt;/span>).FriendlyName = &lt;span style="color:#e6db74">&amp;#39;*.domain.com_2023&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Set a Sharepoint Online site to Read-Only or Disabled</title><link>https://adminbraindump.com/post/sharepoint-online-site-lock/</link><pubDate>Mon, 29 Aug 2022 16:03:16 -0700</pubDate><guid>https://adminbraindump.com/post/sharepoint-online-site-lock/</guid><description>&lt;p>Sharepoint Online (SPO) management tools provided by Microsoft leave something to be desired, to say the least. The admin center web GUI is missing an enormous amount of functionality and the Powershell module is pretty unintuitive. While I don&amp;rsquo;t use a ton of SPO, I recently migrated a site to a different M365 tenant and had the need to set that site to a Read-Only state for a period of time (to ensure we had something to reference in the event someone reported that something was missing) and then disable access to it entirely. Using the SPO Powershell Module, you can quickly and easily change the &lt;code>LockState&lt;/code> attribute of an SPO site.&lt;/p>
&lt;p>First connect to SPO using the administrative URL of your M365 tenant using the &lt;a class="link" href="https://docs.microsoft.com/en-us/powershell/module/sharepoint-online/connect-sposervice?view=sharepoint-ps" target="_blank" rel="noopener"
>Connect-SPOService&lt;/a> command. The administrtive URL you connect to is always the same format:&lt;br>
&lt;code>Connect-SPOService -Url https://tenantname-admin.sharepoint.com&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/sharepoint-online-site-lock/spo-connect.png"
width="885"
height="383"
srcset="https://adminbraindump.com/post/sharepoint-online-site-lock/spo-connect_hu15503644576939382411.png 480w, https://adminbraindump.com/post/sharepoint-online-site-lock/spo-connect_hu16741895878655219951.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="231"
data-flex-basis="554px"
>&lt;/p>
&lt;p>Once connected, set the &lt;code>LockState&lt;/code> property of the site accordingly using the &lt;a class="link" href="https://docs.microsoft.com/en-us/powershell/module/sharepoint-online/set-sposite?view=sharepoint-ps" target="_blank" rel="noopener"
>Set-SPOSite&lt;/a> command. This property can accept three values:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Unlocked&lt;/code> - Default state, site is available&lt;/li>
&lt;li>&lt;code>ReadOnly&lt;/code> - Site is in a view only state so no changes can be made. A message appears at the top of the site indicating that the administrator is preventing any changes from being made to this site. Permissions of folders can be viewed but whether or not those permissions are inheriting&lt;/li>
&lt;li>&lt;code>NoAccess&lt;/code> - Disables the site entirely. If the tenant has a value for &lt;code>NoAccessRedirectUrl&lt;/code> then all traffic will be forward to that URL. If that value is not set, then a 403 error will be returned for all visitors of the site.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>Connect-SPOService -Url &lt;span style="color:#e6db74">&amp;#34;https://tenantname-admin.sharepoint.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set-SPOSite -Identity &lt;span style="color:#e6db74">&amp;#34;https://tenantname.sharepoint.com/sites/Company&amp;#34;&lt;/span> -LockState &lt;span style="color:#e6db74">&amp;#34;ReadOnly&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>About</title><link>https://adminbraindump.com/about/</link><pubDate>Mon, 29 Aug 2022 00:00:00 +0000</pubDate><guid>https://adminbraindump.com/about/</guid><description>&lt;p>Wes Domon is a seasoned IT Infrastructure Engineer with over a decade of experience in the industry. Whether it be onprem systems like Active Directory, VMware vCenter, Powershell automation, or cloud systems like Azure/AWS infrastructure, Azure AD, Azure Bicep deployments, Exchange Online, Wes has been learning and growing his experience within IT while adding and driving solution architecture through a more modern lens. Passionate about technology and the IT industry&amp;rsquo;s trajectory, he is dedicated to process improvement and adaptation through adoption.&lt;/p>
&lt;p>This site is a way to simultaneously be an organizational method for notetaking while, hopefully, serving as a resource for IT admins at any stage of their career. Nothing on this website is intended to represent the views or positions of any other individual or company.&lt;/p></description></item><item><title>Create a new post in Hugo</title><link>https://adminbraindump.com/post/hugo-new-post/</link><pubDate>Sat, 27 Aug 2022 18:46:26 -0700</pubDate><guid>https://adminbraindump.com/post/hugo-new-post/</guid><description>&lt;p>Creating a new post using &lt;a class="link" href="https://gohugo.io/" target="_blank" rel="noopener"
>hugo&lt;/a> is literally a one-liner. Just make sure to set the path inside the &amp;lsquo;post&amp;rsquo; folder.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/hugo-new-post/hugo-new-post.png"
width="806"
height="161"
srcset="https://adminbraindump.com/post/hugo-new-post/hugo-new-post_hu16806487719723948521.png 480w, https://adminbraindump.com/post/hugo-new-post/hugo-new-post_hu417207705525064080.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="500"
data-flex-basis="1201px"
>&lt;/p>
&lt;p>After creating the post, update/save the markdown file then commit and push to the Github repo.&lt;/p>
&lt;p>&lt;img src="https://adminbraindump.com/post/hugo-new-post/hugo-new-post-commit.png"
width="1639"
height="1060"
srcset="https://adminbraindump.com/post/hugo-new-post/hugo-new-post-commit_hu12814736256854256558.png 480w, https://adminbraindump.com/post/hugo-new-post/hugo-new-post-commit_hu15667618352949983893.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="154"
data-flex-basis="371px"
>&lt;/p></description></item><item><title>Block an IP address on Azure App Service</title><link>https://adminbraindump.com/post/azure-app-service-block-ip/</link><pubDate>Sat, 27 Aug 2022 18:01:14 -0700</pubDate><guid>https://adminbraindump.com/post/azure-app-service-block-ip/</guid><description>&lt;p>If malicious/suspicious user activity (scanning, auth attempts, etc.) is detected on an Azure App Service, blocking the source IP is often the quickest way to prevent further activity. To do so, it&amp;rsquo;s as easy as adding a Network rule to the app service that blocks that IP/range.&lt;/p>
&lt;h3 id="requirements">Requirements&lt;/h3>
&lt;ul>
&lt;li>&lt;a class="link" href="https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-8.2.0" target="_blank" rel="noopener"
>Azure Az Powershell Module&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Backticks for formatting&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Add-AzWebAppAccessRestrictionRule `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-ResourceGroupName &lt;span style="color:#e6db74">&amp;#34;ResourceGroup&amp;#34;&lt;/span> `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-WebAppName &lt;span style="color:#e6db74">&amp;#34;AppName&amp;#34;&lt;/span> `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-Name &lt;span style="color:#e6db74">&amp;#34;Ip example rule&amp;#34;&lt;/span> ` &lt;span style="color:#75715e">#Friendly name of rule&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-Priority &lt;span style="color:#ae81ff">100&lt;/span> ` &lt;span style="color:#75715e">#If this app is publicly available, make sure this priority is lower than the priority of the 0.0.0.0/0 rule&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-Action Deny `
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-IpAddress &lt;span style="color:#ae81ff">122.133&lt;/span>.144.&lt;span style="color:#ae81ff">155&lt;/span>/&lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-powershell" data-lang="powershell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Same command one-liner&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Add-AzWebAppAccessRestrictionRule -ResourceGroupName &lt;span style="color:#e6db74">&amp;#34;ResourceGroup&amp;#34;&lt;/span> -WebAppName &lt;span style="color:#e6db74">&amp;#34;AppName&amp;#34;&lt;/span> -Name &lt;span style="color:#e6db74">&amp;#34;Ip example rule&amp;#34;&lt;/span> -Priority &lt;span style="color:#ae81ff">100&lt;/span> -Action Deny -IpAddress &lt;span style="color:#ae81ff">122.133&lt;/span>.144.&lt;span style="color:#ae81ff">155&lt;/span>/&lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="doing-things-the-old-way">Doing things the old way&lt;/h3>
&lt;p>In the Azure web GUI, access the app service in question and click the &amp;ldquo;Networking&amp;rdquo; navigation blade on the left.&lt;/p>
&lt;p>Click &amp;ldquo;Access restriction&amp;rdquo;&lt;br>
&lt;img src="https://adminbraindump.com/post/azure-app-service-block-ip/access-restriction.png"
width="377"
height="315"
srcset="https://adminbraindump.com/post/azure-app-service-block-ip/access-restriction_hu11336617122917741774.png 480w, https://adminbraindump.com/post/azure-app-service-block-ip/access-restriction_hu14632160434427123076.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="119"
data-flex-basis="287px"
>&lt;/p>
&lt;p>Click &amp;ldquo;Add rule&amp;rdquo;&lt;br>
&lt;img src="https://adminbraindump.com/post/azure-app-service-block-ip/add-rule.png"
width="349"
height="488"
srcset="https://adminbraindump.com/post/azure-app-service-block-ip/add-rule_hu17050335760235723382.png 480w, https://adminbraindump.com/post/azure-app-service-block-ip/add-rule_hu12700498886622059684.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="71"
data-flex-basis="171px"
>&lt;/p>
&lt;p>Give the rule a name, change the toggle to &amp;ldquo;Deny,&amp;rdquo; set a priority for the rule (if this is a publicly available app service, make sure to set the new rule with a lower priority than the &amp;ldquo;Allow All&amp;rdquo; rule that exists (0.0.0.0/0), add the CIDR notation of the IP address in question, and click the &amp;ldquo;Add rule&amp;rdquo; button to save the changes. All traffic from that IP address will immediately be blocked.&lt;br>
&lt;img src="https://adminbraindump.com/post/azure-app-service-block-ip/rule-settings.png"
width="382"
height="578"
srcset="https://adminbraindump.com/post/azure-app-service-block-ip/rule-settings_hu11273506513837982364.png 480w, https://adminbraindump.com/post/azure-app-service-block-ip/rule-settings_hu2088749393123680557.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="158px"
>&lt;/p></description></item><item><title>Search</title><link>https://adminbraindump.com/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://adminbraindump.com/search/</guid><description/></item></channel></rss>